---
title: "map_by_divisions"
output: html_document
---

```{r, cache = T}
knitr::opts_chunk$set
```

```{r, message = F, warning = F}
library(ggplot2)
library(dplyr)
library(data.table)
library(RSQLite)
library(tmap)
library(tmaptools)
library(sf)
# library(Hmisc)
library(tidyr)
# library(plyr)
# library(reshape2)
library(knitr)
library(kableExtra)
library(xml2)
library(leaflet)
library(ggpmisc)
```

```{r, cache = T}
folders <- c(
        './data',
        './data/original_rar',
        './data/division_data',
        './data/division_shapes'
)
url1 <- 'https://www12.statcan.gc.ca/census-recensement/2011/geo/bound-limit/files-fichiers/2016/lcd_000b16a_e.zip'
url2 <- 'https://www150.statcan.gc.ca/n1/tbl/csv/17100139-eng.zip'
for(folder in folders){
        if(!file.exists(folder)){dir.create(folder)}
}
if(!file.exists('./data/original_rar/lcd_000b16a_e.zip')){
        download.file(url1, './data/original_rar/lcd_000b16a_e.zip')
}
if(!file.exists('./data/original_rar/17100139-eng.zip')){
        download.file(url2, './data/original_rar/17100139-eng.zip')
}
if(!file.exists('./data/division_shapes/lcd_000b16a_e.shp')){
        unzip('./data/original_rar/lcd_000b16a_e.zip',
              exdir = './data/division_shapes')
}
if(!file.exists('./data/division_data/17100139.csv')){
        unzip('./data/original_rar/17100139-eng.zip', 
              exdir = './data/division_data')
}
```

```{r, cache = T}
metadata <- read.csv('./data/division_data/17100139_MetaData.csv', 
                     skip = 8, nrows = 306)
popEst <- read.csv('./data/division_data/17100139.csv', 
                   na.strings = '')
shp <- st_read('./data/division_shapes/lcd_000b16a_e.shp', 
               stringsAsFactors = F)
```

### Check Data Integrity

```{r, cache = T}
for(i in colnames(popEst)){
        i_unique <- uniqueN(popEst[,i])
        cmd <- sprintf('Unique values for %s: %d', i, i_unique)
        print(eval(cmd))
}
#OR
#sapply(popEst, uniqueN)
as.data.frame(colMeans(is.na(popEst))*100) %>% 
        kbl() %>% 
        kable_styling(bootstrap_options = c('striped', 
                                      'hover', 
                                      'condensed', 
                                      'responsive'), 
                      full_width = F)
```

`STATUS`, `SYMBOL` and `TERMINATED` can all be removed.
$Sex contains a summation observation 'Both sexes' that should be removed.
Similarly $Age.group contains 'All ages', but it also contains specific age 
summations '70 to 74 years'. It also contains 'Average age' and 'Median age' 
data, which we will remove as well.

Moving on to plotting first. Take the sums of everything.

```{r}
popTot <- popEst[popEst$Age.group == 'All ages' &
                         popEst$Sex == 'Both sexes' &
                         grepl(',', popEst$GEO),
                 c(1:2, 12)]
colnames(popTot) <- c('YEAR', 'GEO', 'POPULATION')
popEst$GEO <- gsub('Ã©', 'é', popEst$GEO)
popEst$GEO <- gsub('Ã¨', 'è', popEst$GEO)
popEst$GEO <- gsub('ÃŽ', 'Î', popEst$GEO)
popEst$CITY <- gsub(', .*', '', popEst$GEO)
popEst$PROVINCE <- gsub('.*, ', '', popEst$GEO)
popTot <- spread(popTot, YEAR, POPULATION)
```

Prepare metadata for merging:

The metadata can act as the glue to merge the population table to the shape data since it contains a `GEO` column that overlaps with the population table and a `CDUID` column that overlaps with the shape data.

```{r}
metadata <- metadata[c(2, 3)]
colnames(metadata) <- c('GEO', 'CDUID')
metadata$CDUID <- gsub('\\[|\\]', '', metadata$CDUID)
```

Merge the metadata, then merge the shape data:

```{r}
popTot <- merge(popTot, metadata)
popMap <- st_as_sf(merge(popTot, shp))
```

Plotting the Data:

Here are a few choropleth maps describing population data:

```{r}
ggplot() + 
        geom_sf(data = popMap, aes(fill = `2020`-`2019`))
```

Data is skewed. Check the relationship between variables to best determine how to normalize.

```{r}
ggplot(data = popMap, aes(x = `2019`, y = `2020`-`2019`)) +
    geom_point()
```


```{r, cache = T}
ggplot() + 
    geom_sf(data = popMap, aes(fill = (`2020`-`2019`)/`2019`)) +
    scale_fill_gradient2()
```

```{r, cache = T}
popMap$test <- log10(abs(popMap$`2020`-popMap$`2019`))
popMap$test[is.na(log10(popMap$`2020`-popMap$`2019`))] <- popMap$test[is.na(log10(popMap$`2020`-popMap$`2019`))] * -1
```

```{r, cache = T}
ggplot() + 
    geom_sf(data = popMap, aes(fill = test)) +
    scale_fill_gradient2()
```





Some analysis of data relationship for power law applicability:

```{r}
popMap$`2020-2019` <- popMap$`2020`-popMap$`2019`
my.formula <- y ~ x
ggplot(data = popMap, aes(x = `2019`, y = `2020`-`2019`)) +
        geom_point(color = 'dodgerblue3', alpha = 0.2) +
        geom_smooth(method = 'lm', color = 'black') +
        stat_poly_eq(formula = my.formula,
                     aes(label = paste(..eq.label.., 
                                       ..rr.label.., sep = '~~~')),
                     parse = T)
        

ggplot(data = popMap, aes(x = `2019`, y = `2020`-`2019`)) +
    geom_point(color = 'dodgerblue3', alpha = 0.2) +
        geom_smooth(method = 'lm', color = 'black') + 
        stat_poly_eq(formula = my.formula,
                     aes(label = paste(..eq.label.., 
                                       ..rr.label.., sep = '~~~')),
                     parse = T) +
        xlim(0, 300000) + ylim(-1000, 5000)
```


Reducing the skew by accounting for population size.

```{r}
ggplot(data = popMap, aes(x = `2019`, y = (`2020`-`2019`)/`2019`)) +
        geom_point(color = 'dodgerblue3', alpha = 0.2) +
        geom_smooth(method = 'lm', color = 'black') +
        stat_poly_eq(formula = my.formula,
                     aes(label = paste(..eq.label..,
                                       ..rr.label.., sep = '~~~')),
                     parse = T)
```

Reducing skew by taking the log.

```{r}
ggplot(data = popMap, aes(x = `2019`, y = test)) +
        geom_point(color = 'dodgerblue3', alpha = 0.2) +
        geom_smooth(method = 'lm', color = 'black') +
        stat_poly_eq(formula = my.formula,
                     aes(label = paste(..eq.label..,
                                       ..rr.label.., sep = '~~~')),
                     parse = T)
``` 






